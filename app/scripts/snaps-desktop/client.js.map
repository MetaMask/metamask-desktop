{"version":3,"file":"client.js","sourceRoot":"","sources":["../src/client.ts"],"names":[],"mappings":"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","sourcesContent":["/* eslint-disable consistent-return */\nimport {\n  isJsonRpcRequest,\n  isJsonRpcSuccess,\n  isValidJson,\n  JsonRpcId,\n  JsonRpcRequest,\n  JsonRpcResponse,\n} from '@metamask/utils';\nimport { EthereumRpcError, ethErrors } from 'eth-rpc-errors';\nimport nanoid from 'nanoid';\nimport { RawData, WebSocket } from 'ws';\nimport { createHandshakeKeyPair, decrypt, encrypt } from './encryption';\nimport {\n  getJsonRpcError,\n  getJsonRpcRequest,\n  getJsonRpcResponse,\n  isJsonRpcResponse,\n  safeJSONParse,\n} from './json';\n\nexport enum JsonRpcMethod {\n  Handshake = 'server_handshake',\n  HandleEncryptedMessage = 'server_handleEncryptedMessage',\n}\n\nexport enum EncryptedJsonRpcMethod {\n  Ping = 'ping',\n}\n\nexport type Handlers = Record<string, Handler>;\n\nexport type Handler = (request: JsonRpcRequest<unknown>) => Promise<string>;\n\n/**\n * Get a message from raw WebSocket data. The message may sometimes be a buffer,\n * so this function will attempt to parse it to a string.\n *\n * @param message - The raw WebSocket message.\n * @returns The message as a string.\n */\nconst getMessage = (message: RawData): string => {\n  return message.toString();\n};\n\nexport type WebSocketClient = ReturnType<typeof createWebSocketClient>;\n\n/**\n * Create a WebSocket client from a WebSocket. This client can both send and receive JSON-RPC\n * requests.\n *\n * @param socket - The socket itself.\n * @param handlers - Handlers to run for specific RPC methods.\n * @returns An instance of the WebSocket client.\n */\nexport const createWebSocketClient = (\n  socket: WebSocket,\n  handlers: Handlers,\n) => {\n  const { privateKey, publicKey } = createHandshakeKeyPair();\n  let otherPublicKey: string | null = null;\n\n  // Keep track of pending requests\n  const requests: Record<string, { resolve: any; reject: any }> = {};\n\n  /**\n   * Send an arbitrary message to the client. This is expected to be a valid\n   * JSON message, and is stringified before sending.\n   *\n   * @param message - The JSON message to send.\n   * @returns Nothing.\n   */\n  const reply = (message: unknown) => {\n    if (!isValidJson(message)) {\n      return socket.send(\n        JSON.stringify(\n          getJsonRpcError(null, ethErrors.rpc.internal().serialize()),\n        ),\n      );\n    }\n\n    socket.send(JSON.stringify(message));\n  };\n\n  const request = (id: JsonRpcId, message: unknown) => {\n    const promise = new Promise((resolve, reject) => {\n      requests[id as string] = { resolve, reject };\n    });\n\n    // Send message\n    reply(message);\n\n    // Wait for response\n    return promise;\n  };\n\n  const performHandshake = async () => {\n    const id = nanoid();\n    const req = getJsonRpcRequest(id, JsonRpcMethod.Handshake, [publicKey]);\n\n    otherPublicKey = (await request(id, req)) as string;\n  };\n\n  const requestEncrypted = async <Params>(req: JsonRpcRequest<Params>) => {\n    if (!otherPublicKey) {\n      // TODO: Perform handshake?\n      throw new Error('Handshake has not been performed yet.');\n    }\n\n    const { id } = req;\n\n    if (id && id in requests) {\n      throw new Error(\n        'The request ID has been used before. It must be a unique value for each request.',\n      );\n    }\n\n    const message = encrypt(JSON.stringify(req), otherPublicKey);\n    const json = getJsonRpcRequest(id, JsonRpcMethod.HandleEncryptedMessage, [\n      message,\n    ]);\n\n    if (!id) {\n      // Send notifications without waiting\n      reply(json);\n      return;\n    }\n\n    return await request(id, json);\n  };\n\n  /**\n   * Send a JSON-RPC response to the client, with an encrypted payload. The\n   * result is automatically encrypted with the shared encryption key.\n   *\n   * @param requestId - The ID of the request to reply to.\n   * @param result - The result to send.\n   * @returns Nothing.\n   */\n  const replyEncrypted = (requestId: JsonRpcId, result: unknown) => {\n    if (!otherPublicKey) {\n      // TODO: Perform handshake?\n      throw new Error('Handshake has not been performed yet.');\n    }\n\n    // Result cannot be undefined because JSON doesn't support undefined.\n    const encryptedResult = encrypt(\n      JSON.stringify(result ?? null),\n      otherPublicKey,\n    );\n\n    return reply(getJsonRpcResponse(requestId, encryptedResult));\n  };\n\n  /**\n   * Verify a string as a JSON-RPC request. If the string is not a valid\n   * JSON-RPC request, this sends an error to the client, and returns\n   * undefined. Otherwise, this returns the parsed request object.\n   *\n   * @param message - The string to parse.\n   * @returns The parsed request object, or undefined if the string is not a\n   * valid JSON-RPC request.\n   */\n  const verify = (\n    message: string,\n  ): JsonRpcRequest<unknown> | JsonRpcResponse | undefined => {\n    const [parseError, json] = safeJSONParse(message);\n    if (parseError || !isValidJson(json)) {\n      reply(getJsonRpcError(null, ethErrors.rpc.invalidInput().serialize()));\n      return undefined;\n    }\n\n    const validatedJson = json as JsonRpcRequest<unknown>;\n    if (!isJsonRpcRequest(validatedJson) && !isJsonRpcResponse(json)) {\n      reply(\n        getJsonRpcError(\n          (validatedJson as JsonRpcRequest<unknown>).id ?? null,\n          ethErrors.rpc.invalidRequest().serialize(),\n        ),\n      );\n      return undefined;\n    }\n\n    return validatedJson;\n  };\n\n  /**\n   * Handle a handshake request. This computes the shared encryption key and\n   * sends a response to the client, with the server's public key.\n   *\n   * @param request - The JSON-RPC request.\n   * @param request.id - The ID of the request.\n   * @param request.params - The parameters of the request.\n   * @returns Nothing.\n   */\n  const handshake = ({ id: requestId, params }: JsonRpcRequest<unknown[]>) => {\n    // Handshake can only be performed once\n    if (otherPublicKey) {\n      return reply(\n        getJsonRpcError(requestId, ethErrors.rpc.invalidRequest().serialize()),\n      );\n    }\n\n    if (!Array.isArray(params) || typeof params[0] !== 'string') {\n      return reply(\n        getJsonRpcError(requestId, ethErrors.rpc.invalidParams().serialize()),\n      );\n    }\n\n    otherPublicKey = params[0];\n\n    return reply(getJsonRpcResponse(requestId, publicKey));\n  };\n\n  /**\n   * Handle an encrypted message. This decrypts the message and replies with\n   * a new encrypted message. This can only be called after the handshake\n   * has been performed.\n   *\n   * @param request - The JSON-RPC request.\n   * @param request.id - The ID of the request.\n   * @param request.params - The parameters of the request.\n   * @returns Nothing.\n   */\n  const handleEncryptedMessage = async ({\n    id: requestId,\n    params,\n  }: JsonRpcRequest<unknown>) => {\n    if (!otherPublicKey) {\n      return reply(\n        getJsonRpcError(requestId, ethErrors.rpc.invalidRequest().serialize()),\n      );\n    }\n\n    if (!Array.isArray(params) || typeof params[0] !== 'string') {\n      return reply(getJsonRpcError(requestId, ethErrors.rpc.invalidParams()));\n    }\n\n    const encryptedMessage = params[0];\n    const message = decrypt(encryptedMessage, privateKey);\n\n    const validatedJson = verify(message) as JsonRpcRequest<unknown>;\n    if (!validatedJson) {\n      return;\n    }\n\n    if (validatedJson.method === EncryptedJsonRpcMethod.Ping) {\n      return replyEncrypted(requestId, 'pong');\n    }\n\n    const handler = handlers[validatedJson.method];\n    if (handler) {\n      try {\n        const result = await handler(validatedJson);\n        if (!validatedJson.id) {\n          return;\n        }\n        return replyEncrypted(requestId, result);\n      } catch (err) {\n        const serialized =\n          err instanceof EthereumRpcError\n            ? err.serialize()\n            : ethErrors.rpc.internal().serialize();\n\n        return reply(getJsonRpcError(requestId, serialized));\n      }\n    }\n\n    return reply(\n      getJsonRpcError(requestId, ethErrors.rpc.methodNotFound().serialize()),\n    );\n  };\n\n  socket.addEventListener('message', (event) => {\n    const message = getMessage(event.data as RawData);\n    const verifiedJson = verify(message);\n    if (!verifiedJson) {\n      return;\n    }\n\n    if (isJsonRpcResponse(verifiedJson)) {\n      const validatedJson = verifiedJson as JsonRpcResponse;\n      if (!validatedJson.id || !(validatedJson.id in requests)) {\n        return;\n      }\n\n      const { resolve, reject } = requests[validatedJson.id];\n      if (isJsonRpcSuccess(validatedJson)) {\n        if (otherPublicKey) {\n          const [error, json] = safeJSONParse(\n            decrypt(validatedJson.result as string, privateKey),\n          );\n\n          if (error) {\n            return reject(ethErrors.rpc.internal().serialize());\n          }\n\n          return resolve(json);\n        }\n\n        return resolve(validatedJson.result);\n      }\n\n      return reject(validatedJson.error);\n    }\n\n    // We know it to be a request then\n    // TODO: Handle errors?\n    const validatedJson = verifiedJson as JsonRpcRequest<unknown>;\n    const { method, id } = validatedJson;\n    if (method === JsonRpcMethod.Handshake) {\n      return handshake(validatedJson as JsonRpcRequest<unknown[]>);\n    }\n\n    if (method === JsonRpcMethod.HandleEncryptedMessage) {\n      return handleEncryptedMessage(validatedJson);\n    }\n\n    return reply(\n      getJsonRpcError(id, ethErrors.rpc.methodNotFound().serialize()),\n    );\n  });\n\n  return { performHandshake, requestEncrypted };\n};\n"]}